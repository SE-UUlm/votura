---
title: Cryptographic Workflow
description: The cryptographic workflow and design of votura.
tags:
  - Design
  - Cryptography
hide_table_of_contents: false
# sidebar_position: 1
draft: false
---

:::warning

This page is still under construction and will be updated soon.

:::

## Voting Process and Cryptographic Maths

When an administrative user "freezes" an election (i.e. when the election configurations e.g. start and end dates etc. are set and become immutable), a key pair for the El Gamal algorithm is generated. This key pair consists of:

- a public key with values
  - `p` - a large prime number (2048 bits or more) that defines the group
  - `q` - prime number that divides `(p-1)`, often chosen as `(p-1)/2`
  - `g` - generator of the multiplicative group modulo `p`
  - `y` - public key with `y = g^x mod p`
- and a secret key `x`, randomly chosen such that `1 < x < p`.

### 1a El Gamal encryption

Encryption starts when the voter confirms their choices and _before_ any information is sealed and sent to the server. The voter expresses their choices by encrypting `1` or `0` for each option, depending on whether they want to support that option or not. With the plaintext `m` (expected as a big integer) and a randomness `r < q` a ciphertext `(alpha, beta)` is generated for each option as follows:

- `alpha = g^r mod p`
- `beta = m * y^r mod p`.

The value of `m` is actually never `0`, which would be not cryptographically secure. Instead, `0` and `1` are actually encoded as `Enc(0) = g^0` and `Enc(1) = g^1`, which are two elements of the group generated by `g`, as needed for El Gamal encryption. It is called "exponential El Gamal" and makes ciphertexts additively homomorphic, i.e. the product of an encryption of `g^i` and an encryption of `g^j` is an encryption of `g^(i+j)`.

At this point, an audit option is available to the voter. If this was done, the ciphertexts and the randomness used to create them are displayed, so the voter can verify, if the ballot system had encrypted the answers correctly. Then, the revealed randomness and its ciphertexts are discarded and a new randomness `r < q` is chosen to generate a new ciphertext `(alpha, beta)` for each option - like before.

### 1b Proof of correct encryption

Next, a disjunctive zero-knowlegde proof is performed. Its core idea is the creation of multiple parallel proofs. There is one real proof for the actual vote cast (`Enc(1)`), and there is one simulated proof for each option that was not chosen by the voter (`Enc(0)`). These proofs are indistinguishable from each other by a verifier, but together they show:

In an election with multiple options, exactly one option was selected, without revealing which one.

Therefore, at first for the ciphertext `(alpha, beta)` of each unchosen option `m` an encryption proof is simulated as follows:

- `challenge` - randomly chosen number with `challenge < q`
- `response` - randomly chosen number with `response < q`
- `commitment = ( alpha^(-challenge) * g^response mod p, (beta / m)^(-challenge) * y^response mod p )`.

Then, using a random value `w < q`, the real proof for the actual vote cast is calculated as follows:

- `commitment = ( g^w mod p, y^w mod p )`
- `challenge` - hash value over a list of all (simulated and real) commitments, reduced by subtracting all simulated challenges, modulo `q`
- `response = w + randomness * challenge mod q`.

The value of `randomness` has to be the randomness `r` that was used in 1a to create the ciphertexts with El Gamal algorithm. In the end, every plaintext and randomness is now discarded.

Only the list of ciphertexts `[(alpha_1, beta_1), (alpha_2, beta_2), ..., (alpha_n, beta_n)]` and the corresponding list of their proofs `[proof_1, proof_2, ..., proof_n]` are left and sent to the server side.

### 1c Verification of encryption proof

On the server side, at first it is checked if the incoming proofs are valid. Therefore, the following statements have to be true for every ciphertext `(alpha, beta)` and its proof `{commitment, challenge, response}`, with `commitment` consisting of `(A, B)`:

- `A^q = 1 mod p` and `B^q = 1 mod p` (`A` and `B` in the correct group)
- `g^response = A * alpha^challenge`
- `y^response = B * (beta/m)^challenge`.

Note that the plaintext `m` does not need to be decrypted from its ciphertext `(alpha, beta)`. The server already knows every possible option the voter can chose (`Enc(0)` or `Enc(1)`). With one of these possible options the last statement must hold.

If all statements above hold for every ciphertext and its proof, then all the ciphertexts will be placed in the "ballot box".

### 2a Homomorphic vote tallying

When the election is over and closed, the tallying phase begins. At this point, it would be possible to shuffle all ciphertexts, decrypt them individually, and then count the votes - all accompanied by cryptographic proofs. In this case, however, the homomorphic property of the El Gamal encryption scheme is utilized. Instead of decrypting each individual ciphertext, all ciphertexts are multiplicatively combined.

Recap: The proof of correct encryption in 1b showed for every voter that in an election with multiple options, exactly one option was selected, without revealing which one.

Now, in the "ballot box" there is a set of encrypted votes with each vote consisting of a list of ciphertexts `[(alpha_1, beta_1), (alpha_2, beta_2), ..., (alpha_n, beta_n)]` and each of these `n` ciphertexts containing the information whether or not the voter selected the corresponding option (`Enc(1)` or `Enc(0)`). With this in mind, for each ciphertext `(alpha_i, beta_i)` of all votes:

- `alpha = Product(alpha_i) mod p` (product of all `alpha_i` of all votes)
- `beta = Product(beta_i) mod p` (product of all `beta_i` of all votes).

The resulting ciphertext `(alpha, beta)` now contains the encrypted sum of votes for option `i`. Any information about each voter's selection is thus lost. Instead, there are only `n` ciphertexts left, each containing the encrypted sum of votes for the corresponding option.

### 2b Public verifiability

Before decryption takes place, public verifiability ensures that the set of encrypted votes used in the homomorphic tally is complete and unmodified. This includes two main components:

- Individual verifiability: Each voter can verify that their encrypted vote was correctly included in the published set of ciphertexts, typically by checking a cryptographic hash or commitment computed over their submitted vote. These values are published on a public bulletin board or audit trail. If the commitment matches, the vote has not been altered or omitted.
- Universal verifiability: All parties can verify that the homomorphic aggregation of the encrypted votes was performed correctly. Since all encrypted votes and their zero-knowledge proofs are public, anyone can independently recompute the aggregate ciphertexts for each option and verify that the combined results match the published tally ciphertexts.

This step does not reveal any vote content, but it guarantees that only valid, correctly encrypted votes were included in the tally and that the homomorphic computations were performed without manipulation. It is skipped if it was deselected in the election configuration.

### 3a Decryption

Recap: After the homomorphic vote tallying in 2a, there are only `n` ciphertexts left, each containing the encrypted sum of votes for the corresponding option.

To decrypt a ciphertext `(alpha, beta)`, a decryption factor is computed as follows:

- `dec_factor = alpha^x = g^(y*x) mod p`.

Then, the modular inverse of this factor is computed with `dec_factor^(-1) mod p`, before finally the plaintext `m` is recovered as follows:

- `m = beta * dec_factor^(-1) mod p`.

With this, all `n` ciphertexts are decrypted and the election results can be published.

### 3b Proof of Decryption

The proof of decryption follows the Chaum-Pedersen protocol and is used to verify the correctness of the El Gamal decryption, without revealing the secret key `x` or randomness `r` used in the encryption process.

Therefore, the server needs to prove that it knows `x` such that:

- `y = g^x mod p`
- `alpha^x = d = g^(xr)`.

This is a zero-knowledge proof of equality of discrete logs.

With a ciphertext `(alpha, beta)` and a random value `w < q`, the proof is calculated as follows:

- `commitment = ( g^w mod p, alpha^w mod p )`
- `challenge` - hash value over the commitment (Fiat-Shamir hash)
- `response = w + challenge * x mod q`.

### 3c Verification of decryption proof

To verify the proof of decryption the following statements have to be true for the ciphertext `(alpha, beta)`, its decryption `m` and the above proof `{commitment, challenge, response}`, with `commitment` consisting of `(A, B)`:

- `g^response = A * y^challenge`
- `alpha^response = B * (beta/m)^challenge`.

If both equations hold the verifier can be convinced that the prover knows the secret `x`. Hence, the decryption is correct.

## Cryptographic Workflow

The following diagram shows the cryptographic workflow of votura:

![the cryptographic workflow of votura](../../../static/img/cryptoWorkflow.png)
